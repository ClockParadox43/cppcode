#### 简介
> 只要记住`p[]`记录的是：到下标`i`为止，**最大**的前缀和后缀相等的长度
> <img src="https://pic.imgdb.cn/item/64a450911ddac507cc0b16ab.jpg" width=20%>
> 跳出去的那部分之前的位置是**不用匹配的位置**
> <img src="https://pic.imgdb.cn/item/64a452a51ddac507cc0f39b1.jpg" width=30%>
#### AC代码 + 解释
```c++
// 暴力做法是将整个模板串往后移动一位, 重新开始匹配，太慢了
// 所以考虑将模板串最多往后移多少就可以重新开始匹配
//
// next[i]含义:以 i 为终点的后缀和从 1 开始的前缀相等, 后缀的长度最长
// 求模板串后缀和前缀相等, 相等的最大长度是多少
//
// 时间复杂度:因为主串指针没有发生回退, 模式串指针最多回退 m 次
//            所以时间复杂度是 O(N+M) -> O(N)
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
char p[N], s[M];
int ne[N];

int main()
{
    // 因为匹配失败从0开始，所以数组下标从1开始，下标0什么也不存储。
    cin >> n >> p + 1 >> m >> s + 1;
    // 预处理 next 数组:
    //  0 号位置代表要从新匹配, 不存储长度, 1 号位置根本就不存在前缀串所以 i 从 2 开始
    //  0 是判断是否需要重新来过的位置, 所以 j 从 0 开始, 因为是从0位置开始匹配所以i和j+1位置匹配(0位置啥也没有)   
    //  为什么是2: 因为求的是最长前缀, 起码两个字符才能有前缀 
    for (int i = 2, j = 0; i <= n; ++ i )
    {
        while(j && p[i] != p[j + 1]) j = ne[j];   
        if (p[i] == p[j + 1]) ++ j;
        ne[i] = j;
    }

    // 为什么 s[i] 和 p[j + 1] 而不是 s[i] 和 p[j] 对比
    // 因为p[0]代表匹配失败，里面什么都没存储，0对于p[]来说是有用的，所以j从0开始，偏移1位和s匹配
    for (int i = 1, j = 0; i <= m; ++ i )
    {
        // 如果 j 还没有退回起点(退回起点就要重新开始匹配了), 并且主串不能和模板串的下一位去匹配 
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)    
        {
            printf("%d ", i - n);       // 该题下标从 0 开始不要-1, 招到了末尾的位置, 倒着走 N 步就是开始的位置
            j = ne[j];  		// 因为ne[j]求的是最大匹配所以对应最小移动, 保证不遗漏
        }    
    }
    return 0;
}
```
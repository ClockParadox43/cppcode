[toc]
### 1. 队列简介
> 队列是一种**一维**，按照**先进先出**的原则存储数据的数据结构。<br/>
> ![](https://pic.imgdb.cn/item/6486e3fe1ddac507ccc21004.jpg)
#### 1.1. 重要元素
>1. 队列**大小**
>2. **队首**
>3. **队尾**
#### 1.2. 队列的基本操作
>- **入**队列
>- **出**队列
>- 查询从对头往后的第`k`个元素是多少
#### 1.3. 注意
>该队列以`1`作为`base`来实现，区间为**左闭右闭**。
>为了**充分利用第一个位置**所以初始化为：
> - **front = 1、rear = 0**
>
>充分将第一个元素加到第一个位置上，同时也符合了**左闭右闭**。
#### 1.4. 例题
##### 队列 AC代码 + 解释
> **题意**：输入入队列的操作序列，输出出队列序列。
> **注意**：求`从对头往后的第k个元素是多少`，递推公式：
> &emsp;&emsp;&emsp;由于`hh`从`1`开始，所以我们要使得 `hh+k = hh`，因为是从对头开始数，可确定符号`+`，带入值后得出递推公式：`hh+k-1`。
>>>![](https://pic.imgdb.cn/item/6486f9d91ddac507ccf285a6.jpg)
```c++
#include <iostream>

const int MXN = 100010;

int n, q[MXN], hh = 1, tt;
char s[MXN];

int main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cin >> n;
	for (int i = 1; i <= n; ++ i){
		std::cin >> s;
		if (s[2] == 's' || s[2] == 'e'){
			int x; std::cin >> x;
			if (s[2] == 's') q[ ++ tt] = x;
			else std::cout << q[hh + x - 1] << std::endl;
		}else q[hh ++ ];
	}
	return 0;
}
```
##### 队列练习 AC代码 + 解释
>**题意**：
>>- 给定数字x，并且把`x(1≤x≤10000)`放到队列里，你要执行如下操作`k(1≤k≤100000)`次。
>>- 每次记队首的元素为`y`，首先把这个元素从队列中弹出，然后将`2y`和`2y+1`依次放到队列的末尾
>>- 对于每次操作，输出队首的元素`y`。
>
>**注意1**：数字每次 $ {\times}{2} $ 进行递增，下标每 $ {\times}{2} $，数字也会 $ {\times}{2} $ ，最多会进行 $ {\log_2}{k} $ 次 $ {\times}{2} $，其中第一次为$ {x} $的大小为 ${x{\times}2^1}$，第二次为${x{\times}2^2}$ ... 第${k}$次为$x{\times}{2^{\log_2{k}}}$。
>>>>- **ps**：如果理解不了可以想象下成二叉树的层数。
>
> &emsp;&emsp;&emsp;&emsp;有 $2^{{\log_2}{k}} = k，$由于$ {x}{\times}{k} $ 为$ 2^9 $，由于最终的结果只要求输出前$ {k} $次的，所以，一定小于$ 2^9 $，所以用`int`是能做的。<br/>
> **注意2**：由于每次操作都会增加 $ {2} $ 个元素，所以最终的队列长度为 $ {2k + 1} $。
> &emsp;&emsp;&emsp;&ensp;${2k}$为每次都会新增的元素，$ {1} $为最初的元素，由于该队列以 ${1}$ 作为 $base$，所以数组极限范围为 ${2000002}$。
```c++
#include <iostream>

const int MXN = 200011;

int x, k;
int q[MXN];

int main()
{
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cin >> x >> k;
	q[1] = x;
	int hh = 1, tt = 1;
	for (int i = 1; i <= k; ++ i){
		q[ ++ tt] = 2 * q[hh], q[ ++ tt] = 2 * q[hh] + 1;
		std::cout << q[hh ++ ] <<std::endl;	
	}
	return 0;
}
```
##### 数字统计 AC代码 + 解释
>**题意**：
>- 给你一个长度为`n(1≤n≤100000)`的数组，数组里的每一个数字都大于等于它之前的那个数字。
>- 现在要你统计对于每个位置的数字`x(1≤x≤1000000)`，在它之前的所有数字有几个大于等于`x-5`。
